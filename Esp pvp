--[[
    UI LOADER FOR BRM5 v6.5
    - Includes Draggable Mini Button
    - Executes Original Script Without Any Modification
]]

local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- 1. T·∫†O CONTAINER CHO UI M·ªöI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "DexterLoaderUI"
ScreenGui.Parent = game:GetService("CoreGui") -- S·ª≠ d·ª•ng CoreGui ƒë·ªÉ kh√¥ng b·ªã m·∫•t khi reset
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- 2. T·∫†O MINI BUTTON (C√ì TH·ªÇ K√âO)
local MiniButton = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local ButtonLabel = Instance.new("TextLabel")
local MiniBtnAction = Instance.new("TextButton")

MiniButton.Name = "MiniButton"
MiniButton.Parent = ScreenGui
MiniButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
MiniButton.BorderSizePixel = 0
MiniButton.Position = UDim2.new(0, 50, 0, 50)
MiniButton.Size = UDim2.new(0, 50, 0, 50)
MiniButton.Active = true

UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = MiniButton

ButtonLabel.Parent = MiniButton
ButtonLabel.BackgroundTransparency = 1
ButtonLabel.Size = UDim2.new(1, 0, 1, 0)
ButtonLabel.Font = Enum.Font.GothamBold
ButtonLabel.Text = "D"
ButtonLabel.TextColor3 = Color3.new(1, 1, 1)
ButtonLabel.TextSize = 24

MiniBtnAction.Parent = MiniButton
MiniBtnAction.BackgroundTransparency = 1
MiniBtnAction.Size = UDim2.new(1, 0, 1, 0)
MiniBtnAction.Text = ""

-- Logic k√©o cho Mini Button
local dragging, dragInput, dragStart, startPos
local function update(input)
    local delta = input.Position - dragStart
    MiniButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

MiniButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MiniButton.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MiniButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- 3. CH·∫†Y SCRIPT G·ªêC (GI·ªÆ NGUY√äN 100%)
-- Script n√†y s·∫Ω t·ª± t·∫°o GUI c·ªßa n√≥ (frame)
task.spawn(function()
    -- [B·∫ÆT ƒê·∫¶U L·ªÜNH G·ªêC]
    -- -- BRM5 v6.5 by dexter 
-- Credits to ryknuq and their overvoltage script, which helped me understand how to integrate the Aim into my script. Without their script, I don't think I could have done this.

-- Obtaining essential Roblox services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- Local variables for player and configuration
local LocalPlayer = Players.LocalPlayer -- Reference to the local player
local configFile = "Dexter_Config.txt" -- Configuration file name

-- Constants for target detection
local TARGET_NAME = "Male" -- Name of the target NPC model
local TARGET_PART = "Head" -- NPC body part to aim at
local REQUIRED_CHILD = "Wall_Box" -- Name of the required child object to identify valid targets for the Aim
local DEADZONE = 1.5 -- Deadzone for the Aim, to avoid jerky movements with small deltas

-- Tables and state variables
local trackedParts = {} -- Stores NPC parts that are being tracked (for Wall)
local wallConnections = {} -- Stores event connections for Wall
local wallEnabled = false -- Wall state (on/off)
local guiVisible = true -- GUI visibility state
local isUnloaded = false -- Indicates if the script has been unloaded/disabled

-- configuration variables
local aimEnabled = false -- Aim state (on/off)
local smoothing = 95 -- Aim smoothing level (0-100, higher = smoother)
local holdingRightClick = false -- Indicates if the player is holding down the right mouse button
local fovEnabled = false -- FOV (field of view) circle state (on/off)
local fovRadius = 100 -- FOV circle radius in pixels

-- Creation of the FOV circle (initially invisible)
local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.fromRGB(0, 255, 0) -- Green color
fovCircle.Thickness = 2 -- Line thickness
fovCircle.Filled = false -- Do not fill the circle
fovCircle.Visible = false -- Initially invisible

-- Function to save the current configuration to a file
local function saveConfig(config)
    if writefile then -- Checks if the 'writefile' function is available (exploit environments)
        writefile(configFile, HttpService:JSONEncode({ -- Encodes the configuration table to JSON and writes it
            wall = config.wall,
            aim = config.aim,
            fovEnabled = config.fovEnabled,
            fovRadius = config.fovRadius,
            smoothing = config.smoothing
        }))
    end
end

-- Function to load the configuration from a file
local function loadConfig()
    if isfile and isfile(configFile) and readfile then -- Checks if 'isfile' and 'readfile' functions are available and if the file exists
        local success, data = pcall(function() -- Safely tries to decode the JSON file
            return HttpService:JSONDecode(readfile(configFile))
        end)
        if success then -- If decoding was successful
            return { -- Returns the loaded configuration, with default values if any are missing
                wall = data.wall or false,
                aim = data.aim or false,
                fovEnabled = data.fovEnabled or false,
                fovRadius = data.fovRadius or 100,
                smoothing = data.smoothing or 95
            }
        end
    end
    -- Returns the default configuration if the file could not be loaded
    return {
        wall = false,
        aim = false,
        fovEnabled = false,
        fovRadius = 100,
        smoothing = 95
    }
end

-- Loads the configuration when the script starts
local currentConfig = loadConfig() -- Renamed 'config' to 'currentConfig' to avoid conflict with the function parameter name
wallEnabled = currentConfig.wall
aimEnabled = currentConfig.aim
fovEnabled = currentConfig.fovEnabled
fovRadius = currentConfig.fovRadius
smoothing = currentConfig.smoothing

-- Function to destroy all Wall boxes
local function destroyAllBoxes()
    for part, _ in pairs(trackedParts) do
        if part and part.Parent and part:FindFirstChild("Wall_Box") then
            part.Wall_Box:Destroy() -- Destroys the box instance
        end
    end
    trackedParts = {} -- Empties the tracked parts table
end

local function createBoxForPart(part)
    if isUnloaded or not part or part.Parent == nil or part:FindFirstChild("Wall_Box") then return end -- Conditions for not creating the box
    task.wait(0.5) -- Short wait to ensure the part is fully loaded
    if not part or not part.Parent or part:FindFirstChild("Wall_Box") then return end -- Double check

    local box = Instance.new("BoxHandleAdornment") -- Creates the visual object for the Wall
    box.Name = "Wall_Box" -- Object name
    box.Size = part.Size + Vector3.new(0.1, 0.1, 0.1) -- Size slightly larger than the part
    box.Adornee = part -- Associates the box with the NPC part
    box.AlwaysOnTop = true -- Always visible through other objects
    box.ZIndex = 5 -- Rendering order
    box.Color3 = Color3.fromRGB(255, 0, 0) -- Initial color (red by default, will change if visible)
    box.Transparency = 0.3 -- Box transparency
    box.Parent = part -- Parents the box to the part

    trackedParts[part] = true -- Adds the part to the tracked list
end

-- Function to create boxes for all existing NPCs that meet the criteria
local function createBoxesForAllNPCs()
    for _, npc in ipairs(Workspace:GetDescendants()) do -- Iterates over all descendants of the Workspace
        if npc:IsA("Model") and npc.Name == TARGET_NAME then -- If it's a model with the target name
            local head = npc:FindFirstChild(TARGET_PART) -- Looks for the target part (head)
            if head then createBoxForPart(head) end -- If found, creates the box
        end
    end
end

-- Function to register existing NPCs at startup (without creating boxes yet, just adds them to trackedParts)
local function registerExistingNPCs()
    for _, npc in ipairs(Workspace:GetDescendants()) do
        if npc:IsA("Model") and npc.Name == TARGET_NAME then
            local head = npc:FindFirstChild(TARGET_PART)
            if head then trackedParts[head] = true end -- Only registers that it exists
        end
    end
end

-- Creation of the graphical user interface (GUI)
local gui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui")) -- Main GUI container
gui.Name = "AimWallGUI"
gui.ResetOnSpawn = false -- So the GUI doesn't reset when the player respawns
gui.DisplayOrder = 9999 -- High display order to be on top of other GUIs

local frame = Instance.new("Frame", gui) -- Main GUI frame
frame.Size = UDim2.new(0, 260, 0, 418) -- Frame size
frame.Position = UDim2.new(0, 20, 0, 60) -- Frame position
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark background color
frame.Active = true -- Allows the GUI to capture clicks
frame.Draggable = true -- Allows the frame to be draggable
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8) -- Rounded corners for the frame

-- Helper function to create buttons within the frame
local function createButton(text, positionY, color)
    local button = Instance.new("TextButton", frame)
    button.Size = UDim2.new(0.9, 0, 0, 30) -- Size relative to the frame
    button.Position = UDim2.new(0.05, 0, 0, positionY) -- Position relative to the frame
    button.Text = text -- Button text
    button.BackgroundColor3 = color -- Background color
    button.TextColor3 = Color3.new(1, 1, 1) -- Text color (white)
    button.Font = Enum.Font.GothamBold -- Text font
    button.TextSize = 16 -- Text size
    Instance.new("UICorner", button).CornerRadius = UDim.new(0, 6) -- Rounded corners for the button
    return button
end

-- Creation of the GUI title
local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 30)
title.Text = "üéØ BRM5 v4 - by Dexter"
title.TextColor3 = Color3.new(1, 1, 1)
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.BackgroundTransparency = 1 -- Transparent background

-- Creation of the button to enable/disable Wall
local wallBtn = createButton(wallEnabled and "Wall: ON" or "Wall: OFF", 40, Color3.fromRGB(60, 60, 60))
wallBtn.MouseButton1Click:Connect(function() -- Event on button click
    wallEnabled = not wallEnabled -- Toggles the Wall state
    currentConfig.wall = wallEnabled -- Updates the configuration
    saveConfig(currentConfig) -- Saves the configuration
    wallBtn.Text = "Wall: " .. (wallEnabled and "ON" or "OFF") -- Updates the button text
    wallBtn.BackgroundColor3 = wallEnabled and Color3.fromRGB(0, 170, 0) or Color3.fromRGB(60, 60, 60) -- Changes the button color

    -- Updates the transparency of existing boxes based on Wall state
    for part, _ in pairs(trackedParts) do
        local box = part:FindFirstChild("Wall_Box")
        if box and box:IsA("BoxHandleAdornment") then
            box.Transparency = wallEnabled and 0.3 or 1 -- 0.3 if ON, 1 (invisible) if OFF
        end
    end
end)

-- Event to show/hide the GUI when the "Insert" key is pressed
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end -- If the input was already processed by another GUI, do nothing
    if input.KeyCode == Enum.KeyCode.Insert then
        guiVisible = not guiVisible -- Toggles the visibility state
        frame.Visible = guiVisible -- Applies the state to the frame

        -- If the GUI is hidden, locks the cursor to the center for the game
        if not guiVisible then
            UserInputService.MouseIconEnabled = false
            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
        end
    end
end)

-- Creation of the button to enable/disable Aim
local aimBtn = createButton("Aim: OFF", 80, Color3.fromRGB(60, 60, 60))
aimBtn.MouseButton1Click:Connect(function()
    aimEnabled = not aimEnabled -- Toggles the Aim state
    aimBtn.Text = "Aim: " .. (aimEnabled and "ON" or "OFF") -- Updates the text
    aimBtn.BackgroundColor3 = aimEnabled and Color3.fromRGB(0, 170, 0) or Color3.fromRGB(60, 60, 60) -- Changes the color
    currentConfig.aim = aimEnabled -- Updates the configuration
    saveConfig(currentConfig) -- Saves the configuration
end)

-- Creation of the button to enable/disable FOV
local fovBtn = createButton("FOV: OFF", 120, Color3.fromRGB(60, 60, 60))
fovBtn.MouseButton1Click:Connect(function()
    fovEnabled = not fovEnabled -- Toggles the FOV state
    fovBtn.Text = "FOV: " .. (fovEnabled and "ON" or "OFF") -- Updates the text
    fovBtn.BackgroundColor3 = fovEnabled and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(60, 60, 60) -- Changes the color
    currentConfig.fovEnabled = fovEnabled -- Updates the configuration
    saveConfig(currentConfig) -- Saves the configuration
end)

-- Creation of the button to unload/disable the script
local unloadBtn = createButton("Unload", 160, Color3.fromRGB(170, 0, 0)) -- Red color to indicate destructive action
unloadBtn.MouseButton1Click:Connect(function()
    isUnloaded = true -- Marks the script as unloaded
    destroyAllBoxes() -- Destroys all Wall boxes
    fovCircle:Remove() -- Removes the FOV circle
    gui:Destroy() -- Destroys the GUI
    for _, conn in ipairs(wallConnections) do pcall(function() conn:Disconnect() end) end -- Disconnects all event connections
    if mainRenderLoop then mainRenderLoop:Disconnect() end -- Disconnects the main RenderStepped loop (using 'mainRenderLoop' for the first loop)
end)

-- Bot√≥n de No Recoil (Anti-recoil)
local noRecoilBtn = createButton("No Recoil: OFF", 200, Color3.fromRGB(60, 60, 60))
local noRecoilEnabled = false

noRecoilBtn.MouseButton1Click:Connect(function()
    noRecoilEnabled = not noRecoilEnabled
    noRecoilBtn.Text = "No Recoil: " .. (noRecoilEnabled and "ON" or "OFF")
    noRecoilBtn.BackgroundColor3 = noRecoilEnabled and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(60, 60, 60)

    -- C√≥digo que elimina el retroceso si est√° activado
    local weaponsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Shared")
        and game:GetService("ReplicatedStorage").Shared:FindFirstChild("Configs")
        and game:GetService("ReplicatedStorage").Shared.Configs:FindFirstChild("Weapon")
        and game:GetService("ReplicatedStorage").Shared.Configs.Weapon:FindFirstChild("Weapons_Player")

    if weaponsFolder then
        for _, platform in pairs(weaponsFolder:GetChildren()) do
            if platform.Name:match("^Platform_") then
                for _, weapon in pairs(platform:GetChildren()) do
                    for _, child in pairs(weapon:GetChildren()) do
                        if child:IsA("ModuleScript") and child.Name:match("^Receiver%.") then
                            local success, receiver = pcall(require, child)
                            if success and receiver and receiver.Config and receiver.Config.Tune then
                                local tune = receiver.Config.Tune
                                if noRecoilEnabled then
                                    tune.Recoil_X = 0
                                    tune.Recoil_Z = 0
                                    tune.RecoilForce_Tap = 0
                                    tune.RecoilForce_Impulse = 0
                                    tune.Recoil_Range = Vector2.zero
                                    tune.Recoil_Camera = 0
                                    tune.RecoilAccelDamp_Crouch = Vector3.new(1, 1, 1)
                                    tune.RecoilAccelDamp_Prone = Vector3.new(1, 1, 1)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)



-- Function to create a slider control in the GUI
local function createSlider(labelText, min, max, defaultValue, positionY, callback) -- Renamed 'default' to 'defaultValue'
    -- Slider label
    local label = Instance.new("TextLabel", frame)
    label.Size = UDim2.new(1, -20, 0, 20)
    label.Position = UDim2.new(0, 10, 0, positionY)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.new(1, 1, 1)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Text = labelText .. ": " .. defaultValue

    -- Slider background
    local sliderBack = Instance.new("Frame", frame)
    sliderBack.Size = UDim2.new(0.9, 0, 0, 6)
    sliderBack.Position = UDim2.new(0.05, 0, 0, positionY + 22)
    sliderBack.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    Instance.new("UICorner", sliderBack).CornerRadius = UDim.new(0, 4)

    -- Slider button/indicator that is dragged
    local sliderButton = Instance.new("TextButton", sliderBack)
    sliderButton.Size = UDim2.new(0, 10, 1.5, 0) -- Indicator size
    sliderButton.Position = UDim2.new((defaultValue - min) / (max - min), -5, 0, -2) -- Initial position based on the default value
    sliderButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255) -- Indicator color
    sliderButton.Text = "" -- No text
    Instance.new("UICorner", sliderButton).CornerRadius = UDim.new(1, 0) -- Circular indicator

    local dragging = false -- State to know if the slider is being dragged

    -- Event when the slider button is pressed
    sliderButton.MouseButton1Down:Connect(function()
        dragging = true
    end)

    -- Event when the mouse button is released anywhere
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false -- Stop dragging
        end
    end)

    -- Updates the slider position and value while dragging
    RunService.RenderStepped:Connect(function()
        if dragging then
            local mouseXPosition = UserInputService:GetMouseLocation().X -- Mouse X position
            -- Calculates the relative mouse position within the slider background
            local relativeXPosition = math.clamp((mouseXPosition - sliderBack.AbsolutePosition.X) / sliderBack.AbsoluteSize.X, 0, 1)
            local value = math.floor((min + (max - min) * relativeXPosition) + 0.5) -- Calculates the slider value
            sliderButton.Position = UDim2.new(relativeXPosition, -5, 0, -2) -- Updates the indicator position
            label.Text = labelText .. ": " .. value -- Updates the label text
            callback(value) -- Calls the callback function with the new value
        end
    end)
end

-- Creation of the slider for FOV Radius
createSlider("FOV Radius", 0, 500, fovRadius, 240, function(value)
    fovRadius = value -- Updates the global radius variable
    currentConfig.fovRadius = value -- Updates the configuration
    saveConfig(currentConfig) -- Saves the configuration
end)

-- Creation of the slider for Aim Smoothing
createSlider("Smoothing", 0, 100, smoothing, 300, function(value)
    smoothing = value -- Updates the global smoothing variable
    currentConfig.smoothing = value -- Updates the configuration
    saveConfig(currentConfig) -- Saves the configuration
end)

-- Configuration of the instruction label
local instructionLabelYPosition = 298 -- Renamed 'noteLabelY'
local instructionTextContent = "READ before using the script:\nEach time you start a round, during the first few seconds (when you still can't move), press the U key and look at all y
